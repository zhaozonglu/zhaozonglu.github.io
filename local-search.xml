<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis Cluster Gossip协议</title>
    <link href="/2023/05/31/Redis-Cluster-Gossip%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/05/31/Redis-Cluster-Gossip%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>redis-cluster</tag>
      
      <tag>Gossip协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编码AQS详解</title>
    <link href="/2023/05/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A0%81AQS%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/05/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A0%81AQS%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><h2 id="AQS模板方法"><a href="#AQS模板方法" class="headerlink" title="AQS模板方法"></a>AQS模板方法</h2><h3 id="独占锁分析"><a href="#独占锁分析" class="headerlink" title="独占锁分析"></a>独占锁分析</h3><h3 id="共享锁分析"><a href="#共享锁分析" class="headerlink" title="共享锁分析"></a>共享锁分析</h3>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>AQS</tag>
      
      <tag>reentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis集群</title>
    <link href="/2023/05/26/redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/05/26/redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="redis集群介绍"><a href="#redis集群介绍" class="headerlink" title="redis集群介绍"></a>redis集群介绍</h1><p>Redis Cluster 是一种服务器<code>sharding</code>技术，提供在多个redis节点间共享数据的程序集，redis3.0版本之后正式提供支持。<br>用一张图大致可以理解redis Cluster。<img src="/2023/05/26/redis%E9%9B%86%E7%BE%A4/redis-cluster.png" class="" title="[redis-cluster]"></p><p>一个健康的Redis Cluster至少需要3个master，同时每个master节点至少需要一个slave节点。</p><p>Redis Cluster的节点负责维护数据和获取集群状态，这包括将key映射到正确的节点。集群节点同样可以自动发现其他节点、检测不正确工作节点，以及在发生故障时晋升slave节点到master。</p><p>所有集群节点通过tcp和二进制协议组成的被成为Redis Cluster Bus的方式来实现集群的节点自动发现、故障节点探测、slave升级为master等任务，每个节点通过Cluster Bus连接其他节点，节点间通过<strong>gossip</strong>协议进行集群信息传播。</p><h1 id="redis集群数据分片"><a href="#redis集群数据分片" class="headerlink" title="redis集群数据分片"></a>redis集群数据分片</h1><p>redis集群没有使用一致性hash，而是引入哈希槽的概念，redis集群中有16384个哈希槽，每个key通过CRC16校验之后对16383取模来决定放置在哪个槽，同时槽是集群内部数据管理和迁移的基本单位，redis采用大范围槽的主要目的是为了方便数据拆分和集群扩展，Cluster中的每个节点负责一部分hash槽以及槽所映射的键值数据。</p><p><strong>Redis槽分区的特点</strong></p><ul><li>解耦数据和节点之间的关系，简化节点扩容和收缩的难度</li><li>节点自身维护槽的映射关系，不需要向客户端或者代理服务器维护槽分区元数据</li><li>支持节点、槽、键之间映射关系的查询，用于数据路由、在线伸缩等场景</li></ul><h1 id="redis集群hashTag"><a href="#redis集群hashTag" class="headerlink" title="redis集群hashTag"></a>redis集群hashTag</h1><h1 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h1><p>Redis cluster采用去中心化的架构，集群的主节点各自负责一部分槽，客户端如何确定key到底会映射到哪个节点上呢？这就是我们要讲的请求重定向。</p><p><strong>在cluster模式下，节点对请求的处理过程如下：</strong></p><ul><li>检查当前key是否存在当前节点？ <ul><li>通过crc16（key）&#x2F;16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果</li><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？</li><li>若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul><p><font color=red>需要注意的是上述的过程中有MOVED重定向和ACK重定向</font></p><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><p>由于Redis将所有数据分到16384个槽中，每个节点负责一部分槽，槽和节点的对应关系是多对一的关系，此时如果集群中的某个master节点发生故障下线，就会导致该Master节点负责的槽不能继续提供服务。</p><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>Redis集群的故障发现也经历两个阶段：<strong>主观下线</strong>和<strong>客观下线</strong>。比如下图节点1判定节点3下线，那么他会标记节点3的状态为主观下线状态。节点1会通过Gossip消息把这个信息发送给其他节点，接收到信息的节点会进行节点3客观下线状态判定，但是如果绝大部分节点（集群中超过1&#x2F;2数目的节点）都判定节点3为主观下线状态，那么我们就可以断定节点3故障下线，其状态判定为客观下线状态，判定结束后，向集群广播节点3下线消息，其他节点都会更新自己维护的节点3的状态信息，标记3为FAIL。当节点3故障后，我们要采用的故障恢复的方案就是让节点3的子节点代替节点3继续向外提供服务。那么节点3有两个slave节点，到底该选择哪个slave节点来替代呢？这就是我们接下来要介绍的故障迁移。<img src="/2023/05/26/redis%E9%9B%86%E7%BE%A4/redis-fail.png" class="" title="故障发现"></p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>我们接着上面向集群广播消息往下讲。当节点3的的两个Slave节点接收到其主节点的客观下线状态消息时，两个节点就会开始发起故障迁移，竞选成为新的Master节点。两个节点参与竞选之前，首先要检查自身是否有资格参与竞选。</p><p>Slave节点会不停的与Master节点通信来复制Master节点的数据，如果一个Slave节点长时间不与Master节点通信，那么很可能意味着该Slave节点上的数据已经落后Master节点过多（因为Master节点再不停的更新数据但是Slave节点并没有随之更新）。Redis认为，当一个Slave节点过长时间不与Master节点通信，那么该节点就不具备参与竞选的资格。</p><p><strong>故障恢复过程</strong></p><ul><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch加1，并广播Failover Request信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK超过半数后变成新Master</li><li>广播Pong通知其他集群节点</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>redis-cluster</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/24/hello-world/"/>
    <url>/2023/05/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
